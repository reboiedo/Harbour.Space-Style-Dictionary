"use strict";
// Types
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateSpaceScale = exports.calculateTypeScale = exports.calculateClamps = exports.checkWCAG = exports.calculateClamp = void 0;
// Helpers
var lerp = function (x, y, a) { return x * (1 - a) + y * a; };
var clamp = function (a, min, max) {
    if (min === void 0) { min = 0; }
    if (max === void 0) { max = 1; }
    return Math.min(max, Math.max(min, a));
};
var invlerp = function (x, y, a) { return clamp((a - x) / (y - x)); };
var range = function (x1, y1, x2, y2, a) { return lerp(x2, y2, invlerp(x1, y1, a)); };
var roundValue = function (n) { return Math.round((n + Number.EPSILON) * 10000) / 10000; };
var sortNumberAscending = function (a, b) { return Number(a) - Number(b); };
// Clamp
var calculateClamp = function (_a) {
    var maxSize = _a.maxSize, minSize = _a.minSize, minWidth = _a.minWidth, maxWidth = _a.maxWidth, _b = _a.usePx, usePx = _b === void 0 ? false : _b, _c = _a.relativeTo, relativeTo = _c === void 0 ? 'viewport-width' : _c;
    var isNegative = minSize > maxSize;
    var min = isNegative ? maxSize : minSize;
    var max = isNegative ? minSize : maxSize;
    var divider = usePx ? 1 : 16;
    var unit = usePx ? 'px' : 'rem';
    var relativeUnits = {
        viewport: 'vi',
        'viewport-width': 'vw',
        container: 'cqi'
    };
    var relativeUnit = relativeUnits[relativeTo] || relativeUnits.viewport;
    var slope = ((maxSize / divider) - (minSize / divider)) / ((maxWidth / divider) - (minWidth / divider));
    var intersection = (-1 * (minWidth / divider)) * slope + (minSize / divider);
    return "clamp(".concat(roundValue(min / divider)).concat(unit, ", ").concat(roundValue(intersection)).concat(unit, " + ").concat(roundValue(slope * 100)).concat(relativeUnit, ", ").concat(roundValue(max / divider)).concat(unit, ")");
};
exports.calculateClamp = calculateClamp;
/**
 * checkWCAG
 * Check if the clamp confirms to WCAG 1.4.4
 * Many thanks to Maxwell Barvian, creator of fluid.style for this calculation
 * @link https://barvian.me
 * @returns number[] | null
 */
function checkWCAG(_a) {
    var min = _a.min, max = _a.max, minWidth = _a.minWidth, maxWidth = _a.maxWidth;
    if (minWidth > maxWidth) {
        // need to flip because our checks assume minWidth < maxWidth
        var oldMinScreen = minWidth;
        minWidth = maxWidth;
        maxWidth = oldMinScreen;
        var oldmin = min;
        min = max;
        max = oldmin;
    }
    var slope = (max - min) / (maxWidth - minWidth);
    var intercept = min - (minWidth * slope);
    var lh = (5 * min - 2 * intercept) / (2 * slope);
    var rh = (5 * intercept - 2 * max) / (-1 * slope);
    var lh2 = 3 * intercept / slope;
    // this assumes minWidth < maxWidth, hence the flip above
    // These were generated by creating piecewise functions for z5 (the font at 500% zoom in Chrome/Firefox)
    // and 2*z1 (2*the font at 100% zoom; the WCAG requirement), then solving for
    // z5 < 2*z1
    var failRange = [];
    if (maxWidth < 5 * minWidth) {
        if (minWidth < lh && lh < maxWidth) {
            failRange.push(Math.max(lh, minWidth), maxWidth);
        }
        if (5 * min < 2 * max) {
            failRange.push(maxWidth, 5 * minWidth);
        }
        if (5 * minWidth < rh && rh < 5 * maxWidth) {
            failRange.push(5 * minWidth, Math.min(rh, 5 * maxWidth));
        }
    }
    else {
        if (minWidth < lh && lh < 5 * minWidth) {
            failRange.push(Math.max(lh, minWidth), 5 * minWidth);
        }
        if (5 * minWidth < lh2 && lh2 < maxWidth) {
            failRange.push(Math.max(lh2, 5 * minWidth), maxWidth);
        }
        if (maxWidth < rh && rh < 5 * maxWidth) {
            failRange.push(maxWidth, Math.min(rh, 5 * maxWidth));
        }
    }
    // Clean up range
    if (failRange.length) {
        failRange = [failRange[0], failRange[failRange.length - 1]];
        if (Math.abs(failRange[1] - failRange[0]) < 0.1)
            failRange = null; // rounding errors, ignore
    }
    return failRange;
}
exports.checkWCAG = checkWCAG;
var calculateClamps = function (_a) {
    var minWidth = _a.minWidth, maxWidth = _a.maxWidth, _b = _a.pairs, pairs = _b === void 0 ? [] : _b, relativeTo = _a.relativeTo;
    return pairs.map(function (_a) {
        var minSize = _a[0], maxSize = _a[1];
        return {
            label: "".concat(minSize, "-").concat(maxSize),
            clamp: (0, exports.calculateClamp)({ minSize: minSize, maxSize: maxSize, minWidth: minWidth, maxWidth: maxWidth, relativeTo: relativeTo }),
            clampPx: (0, exports.calculateClamp)({ minSize: minSize, maxSize: maxSize, minWidth: minWidth, maxWidth: maxWidth, relativeTo: relativeTo, usePx: true })
        };
    });
};
exports.calculateClamps = calculateClamps;
// Type
var calculateTypeSize = function (config, viewport, step) {
    var scale = range(config.minWidth, config.maxWidth, config.minTypeScale, config.maxTypeScale, viewport);
    var fontSize = range(config.minWidth, config.maxWidth, config.minFontSize, config.maxFontSize, viewport);
    return fontSize * Math.pow(scale, step);
};
var mapStepToLabel = function (step, labelGroup) {
    if (labelGroup === void 0) { labelGroup = "utopia"; }
    if (labelGroup === "utopia")
        return step.toString();
    if (step < -2)
        return "".concat(-1 * (step + 1), "xs");
    if (step === -2)
        return "xs";
    if (labelGroup === "tailwind") {
        if (step === -1)
            return "sm";
        if (step === 0)
            return "base";
        if (step === 1)
            return "lg";
    }
    if (labelGroup === "tshirt") {
        if (step === -1)
            return "s";
        if (step === 0)
            return "m";
        if (step === 1)
            return "l";
    }
    if (step === 2)
        return "xl";
    if (step > 2)
        return "".concat(step - 1, "xl");
    return step.toString();
};
var calculateTypeStep = function (config, step) {
    var minFontSize = calculateTypeSize(config, config.minWidth, step);
    var maxFontSize = calculateTypeSize(config, config.maxWidth, step);
    var wcag = checkWCAG({ min: minFontSize, max: maxFontSize, minWidth: config.minWidth, maxWidth: config.maxWidth });
    return {
        step: step,
        label: mapStepToLabel(step, config.labelStyle),
        minFontSize: roundValue(minFontSize),
        maxFontSize: roundValue(maxFontSize),
        wcagViolation: (wcag === null || wcag === void 0 ? void 0 : wcag.length) ? {
            from: Math.round(wcag[0]),
            to: Math.round(wcag[1]),
        } : null,
        clamp: (0, exports.calculateClamp)({
            minSize: minFontSize,
            maxSize: maxFontSize,
            minWidth: config.minWidth,
            maxWidth: config.maxWidth,
            relativeTo: config.relativeTo
        })
    };
};
var calculateTypeScale = function (config) {
    var positiveSteps = Array.from({ length: config.positiveSteps || 0 })
        .map(function (_, i) { return calculateTypeStep(config, i + 1); }).reverse();
    var negativeSteps = Array.from({ length: config.negativeSteps || 0 })
        .map(function (_, i) { return calculateTypeStep(config, -1 * (i + 1)); });
    return __spreadArray(__spreadArray(__spreadArray([], positiveSteps, true), [
        calculateTypeStep(config, 0)
    ], false), negativeSteps, true);
};
exports.calculateTypeScale = calculateTypeScale;
// Space
var calculateSpaceSize = function (config, multiplier, step) {
    var minSize = Math.round(config.minSize * multiplier);
    var maxSize = Math.round(config.maxSize * multiplier);
    var label = 'S';
    if (step === 1) {
        label = 'M';
    }
    else if (step === 2) {
        label = 'L';
    }
    else if (step === 3) {
        label = 'XL';
    }
    else if (step > 3) {
        label = "".concat(step - 2, "XL");
    }
    else if (step === -1) {
        label = 'XS';
    }
    else if (step < 0) {
        label = "".concat(Math.abs(step), "XS");
    }
    return {
        label: label.toLowerCase(),
        minSize: roundValue(minSize),
        maxSize: roundValue(maxSize),
        multiplier: multiplier,
        clamp: (0, exports.calculateClamp)({
            minSize: minSize,
            maxSize: maxSize,
            minWidth: config.minWidth,
            maxWidth: config.maxWidth,
            relativeTo: config.relativeTo,
        }),
        clampPx: (0, exports.calculateClamp)({
            minSize: minSize,
            maxSize: maxSize,
            minWidth: config.minWidth,
            maxWidth: config.maxWidth,
            relativeTo: config.relativeTo,
            usePx: true,
        })
    };
};
var calculateOneUpPairs = function (config, sizes) {
    return __spreadArray([], sizes.reverse(), true).map(function (size, i, arr) {
        if (!i)
            return null;
        var prev = arr[i - 1];
        return {
            label: "".concat(prev.label, "-").concat(size.label),
            minSize: prev.minSize,
            maxSize: size.maxSize,
            clamp: (0, exports.calculateClamp)({
                minSize: prev.minSize,
                maxSize: size.maxSize,
                minWidth: config.minWidth,
                maxWidth: config.maxWidth,
                relativeTo: config.relativeTo,
            }),
            clampPx: (0, exports.calculateClamp)({
                minSize: prev.minSize,
                maxSize: size.maxSize,
                minWidth: config.minWidth,
                maxWidth: config.maxWidth,
                relativeTo: config.relativeTo,
                usePx: true,
            }),
        };
    }).filter(function (size) { return !!size; });
};
var calculateCustomPairs = function (config, sizes) {
    return (config.customSizes || []).map(function (label) {
        var _a = label.split('-'), keyA = _a[0], keyB = _a[1];
        if (!keyA || !keyB)
            return null;
        var a = sizes.find(function (x) { return x.label === keyA; });
        var b = sizes.find(function (x) { return x.label === keyB; });
        if (!a || !b)
            return null;
        return {
            label: "".concat(keyA, "-").concat(keyB),
            minSize: a.minSize,
            maxSize: b.maxSize,
            clamp: (0, exports.calculateClamp)({
                minWidth: config.minWidth,
                maxWidth: config.maxWidth,
                minSize: a.minSize,
                maxSize: b.maxSize,
                relativeTo: config.relativeTo,
            }),
            clampPx: (0, exports.calculateClamp)({
                minWidth: config.minWidth,
                maxWidth: config.maxWidth,
                minSize: a.minSize,
                maxSize: b.maxSize,
                relativeTo: config.relativeTo,
                usePx: true
            }),
        };
    }).filter(function (size) { return !!size; });
};
var calculateSpaceScale = function (config) {
    var positiveSteps = __spreadArray([], config.positiveSteps || [], true).sort(sortNumberAscending)
        .map(function (multiplier, i) { return calculateSpaceSize(config, multiplier, i + 1); }).reverse();
    var negativeSteps = __spreadArray([], config.negativeSteps || [], true).sort(sortNumberAscending).reverse()
        .map(function (multiplier, i) { return calculateSpaceSize(config, multiplier, -1 * (i + 1)); });
    var sizes = __spreadArray(__spreadArray(__spreadArray([], positiveSteps, true), [
        calculateSpaceSize(config, 1, 0)
    ], false), negativeSteps, true);
    var oneUpPairs = calculateOneUpPairs(config, sizes);
    var customPairs = calculateCustomPairs(config, sizes);
    return {
        sizes: sizes,
        oneUpPairs: oneUpPairs,
        customPairs: customPairs
    };
};
exports.calculateSpaceScale = calculateSpaceScale;
